/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

import { clientsClaim, setCacheNameDetails } from 'workbox-core'
import { createHandlerBoundToURL, precacheAndRoute } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { version as WEB_VERSION } from '@src/../package.json'

declare const self: ServiceWorkerGlobalScope

const DNS_DOMAINS = ['cowswap.exchange', 'barn.cowswap.exchange']
const DEV_DOMAINS_SUFFIX = '.gnosisdev.com'

console.log(`[worker] registerRoutes for v${WEB_VERSION}`)

// Set Cache name
//  See https://dev.to/atonchev/flawless-and-silent-upgrade-of-the-service-worker-2o95
setCacheNameDetails({
  prefix: 'CoW Swap',
  suffix: WEB_VERSION,
})

// Create own skipWaiting
//   We will detect when only one tab is active
self.addEventListener('message', (event) => {
  // Regular skip waiting
  if (event.data && event.data.type === 'SKIP_WAITING') {
    console.log('[worker] Skip waiting')
    self.skipWaiting()
  }

  // Our special skip waiting function!
  if (event.data && event.data.type === 'SKIP_WAITING_WHEN_SOLO') {
    console.log('[worker] Skip waiting when solo')
    self.clients
      .matchAll({
        includeUncontrolled: true,
      })
      .then((clients) => {
        if (clients.length < 2) {
          self.skipWaiting()
        }
      })
  }

  if (event.data && event.data.type === 'PREPARE_CACHES_FOR_UPDATE') {
    console.log('[worker] Prepare cache for update')
    prepareCachesForUpdate().then()
  }
})

self.addEventListener('activate', (event) => {
  event.waitUntil(
    getCacheStorageNames().then(({ outdatedCacheNames }) =>
      outdatedCacheNames.map((cacheName) => {
        console.log('[worker] Delete cache', cacheName)
        // Delete old caches
        // https://developers.google.com/web/ilt/pwa/caching-files-with-service-worker#removing_outdated_caches
        return caches.delete(cacheName)
      })
    )
  )
})

const getCacheStorageNames = async () => {
  const cacheNames = (await caches.keys()) || []
  let latestCacheName
  const outdatedCacheNames = []

  for (const cacheName of cacheNames) {
    if (cacheName.includes(WEB_VERSION)) {
      latestCacheName = cacheName
    } else if (cacheName !== 'images') {
      outdatedCacheNames.push(cacheName)
    }
  }
  return { latestCacheName, outdatedCacheNames }
}

// Copy all the content of index.html from our new service worker into our old service worker, and replace it.
const prepareCachesForUpdate = async () => {
  const { latestCacheName, outdatedCacheNames } = await getCacheStorageNames()
  if (!latestCacheName || !outdatedCacheNames?.length) return null

  const latestCache = await caches?.open(latestCacheName)
  const latestCacheKeys = (await latestCache?.keys())?.map((c) => c.url) || []
  const latestCacheMainKey = latestCacheKeys?.find((url) => url.includes('/index.html'))
  const latestCacheMainKeyResponse = latestCacheMainKey ? await latestCache.match(latestCacheMainKey) : null

  const latestCacheOtherKeys = latestCacheKeys.filter((url) => url !== latestCacheMainKey) || []

  const cachePromises = outdatedCacheNames.map((cacheName) => {
    const getCacheDone = async () => {
      const cache = await caches?.open(cacheName)
      const cacheKeys = (await cache?.keys())?.map((c) => c.url) || []
      const cacheMainKey = cacheKeys?.find((url) => url.includes('/index.html'))
      if (cacheMainKey && latestCacheMainKeyResponse) {
        await cache.put(cacheMainKey, latestCacheMainKeyResponse.clone())
      }

      return Promise.all(
        latestCacheOtherKeys
          .filter((key) => !cacheKeys.includes(key))
          .map((url) => cache.add(url).catch((r) => console.error(r)))
      )
    }
    return getCacheDone()
  })

  return Promise.all(cachePromises)
}

clientsClaim()

// Precache the relevant assets generated by the build process.
const manifest = self.__WB_MANIFEST.filter((entry) => {
  const url = typeof entry === 'string' ? entry : entry.url
  // If this is a language file, skip. They are compiled elsewhere.
  if (url.endsWith('.po')) {
    return false
  }

  // If this isn't a var woff2 font, skip. Modern browsers only need var fonts.
  if (url.endsWith('.woff') || (url.endsWith('.woff2') && !url.includes('.var'))) {
    return false
  }

  return true
})
precacheAndRoute(manifest)

// Set up App Shell-style routing, so that navigation requests are fulfilled
// immediately with a local index.html shell. See
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$')

type IndexRegisterParams = { request: Request; url: URL }
registerRoute((params: IndexRegisterParams) => {
  const { request, url } = params

  // console.log('[worker] Index.html', request, url, params)
  // return false
  // If this isn't a DNS domain skip. IPFS gateways may not have domain
  // separation, so they cannot use App Shell-style routing.
  const hostName = url.hostname
  if (!DNS_DOMAINS.includes(hostName) && !hostName.endsWith(DEV_DOMAINS_SUFFIX)) {
    // console.log('[worker] FALSE. hostname', hostName)
    return false
  }

  // If this isn't a navigation, skip.
  if (request.mode !== 'navigate') {
    // console.log('[worker] FALSE. No navigate', request.mode)
    return false
  }

  // If this looks like a URL for a resource, skip.
  if (url.pathname.match(fileExtensionRegexp)) {
    // console.log('[worker] FALSE. If this looks like a URL for a resource, skip.', request.mode)
    return false
  }

  // console.log('[worker] TRUE!')
  return true
}, createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html'))
