/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers'
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi'
import type { Listener, Provider } from '@ethersproject/providers'
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common'

export interface VCowInterface extends utils.Interface {
  functions: {
    'claim(uint256,uint8,address,uint256,uint256,bytes32[])': FunctionFragment
    'claimMany(uint256[],uint8[],address[],uint256[],uint256[],bytes32[][],uint256[])': FunctionFragment
    'isClaimed(uint256)': FunctionFragment
    'merkleRoot()': FunctionFragment
    'deploymentTimestamp()': FunctionFragment
    'gnoPrice()': FunctionFragment
    'usdcPrice()': FunctionFragment
    'nativeTokenPrice()': FunctionFragment
    'swappableBalanceOf(address)': FunctionFragment
    'balanceOf(address)': FunctionFragment
    'swapAll()': FunctionFragment
  }

  getFunction(
    nameOrSignatureOrTopic:
      | 'claim'
      | 'claimMany'
      | 'isClaimed'
      | 'merkleRoot'
      | 'deploymentTimestamp'
      | 'gnoPrice'
      | 'usdcPrice'
      | 'nativeTokenPrice'
      | 'swappableBalanceOf'
      | 'balanceOf'
      | 'swapAll'
  ): FunctionFragment

  encodeFunctionData(
    functionFragment: 'claim',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[]
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'claimMany',
    values: [
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>[][],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string
  encodeFunctionData(functionFragment: 'isClaimed', values: [PromiseOrValue<BigNumberish>]): string
  encodeFunctionData(functionFragment: 'merkleRoot', values?: undefined): string
  encodeFunctionData(functionFragment: 'deploymentTimestamp', values?: undefined): string
  encodeFunctionData(functionFragment: 'gnoPrice', values?: undefined): string
  encodeFunctionData(functionFragment: 'usdcPrice', values?: undefined): string
  encodeFunctionData(functionFragment: 'nativeTokenPrice', values?: undefined): string
  encodeFunctionData(functionFragment: 'swappableBalanceOf', values: [PromiseOrValue<string>]): string
  encodeFunctionData(functionFragment: 'balanceOf', values: [PromiseOrValue<string>]): string
  encodeFunctionData(functionFragment: 'swapAll', values?: undefined): string

  decodeFunctionResult(functionFragment: 'claim', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'claimMany', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'isClaimed', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'merkleRoot', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'deploymentTimestamp', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'gnoPrice', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'usdcPrice', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'nativeTokenPrice', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'swappableBalanceOf', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'swapAll', data: BytesLike): Result

  events: {
    'Claimed(uint256,uint8,address,uint256,uint256)': EventFragment
  }

  getEvent(nameOrSignatureOrTopic: 'Claimed'): EventFragment
}

export interface ClaimedEventObject {
  index: BigNumber
  claimType: number
  claimant: string
  claimableAmount: BigNumber
  claimedAmount: BigNumber
}
export type ClaimedEvent = TypedEvent<[BigNumber, number, string, BigNumber, BigNumber], ClaimedEventObject>

export type ClaimedEventFilter = TypedEventFilter<ClaimedEvent>

export interface VCow extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this
  attach(addressOrName: string): this
  deployed(): Promise<this>

  interface: VCowInterface

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>
  listeners(eventName?: string): Array<Listener>
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this
  removeAllListeners(eventName?: string): this
  off: OnEvent<this>
  on: OnEvent<this>
  once: OnEvent<this>
  removeListener: OnEvent<this>

  functions: {
    claim(
      index: PromiseOrValue<BigNumberish>,
      claimType: PromiseOrValue<BigNumberish>,
      claimant: PromiseOrValue<string>,
      claimableAmount: PromiseOrValue<BigNumberish>,
      claimedAmount: PromiseOrValue<BigNumberish>,
      merkleProof: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    claimMany(
      indices: PromiseOrValue<BigNumberish>[],
      claimTypes: PromiseOrValue<BigNumberish>[],
      claimants: PromiseOrValue<string>[],
      claimableAmounts: PromiseOrValue<BigNumberish>[],
      claimedAmounts: PromiseOrValue<BigNumberish>[],
      merkleProofs: PromiseOrValue<BytesLike>[][],
      sentEth: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    isClaimed(index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[boolean]>

    merkleRoot(overrides?: CallOverrides): Promise<[string]>

    deploymentTimestamp(overrides?: CallOverrides): Promise<[BigNumber]>

    gnoPrice(overrides?: CallOverrides): Promise<[BigNumber]>

    usdcPrice(overrides?: CallOverrides): Promise<[BigNumber]>

    nativeTokenPrice(overrides?: CallOverrides): Promise<[BigNumber]>

    swappableBalanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>

    balanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>

    swapAll(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>
  }

  claim(
    index: PromiseOrValue<BigNumberish>,
    claimType: PromiseOrValue<BigNumberish>,
    claimant: PromiseOrValue<string>,
    claimableAmount: PromiseOrValue<BigNumberish>,
    claimedAmount: PromiseOrValue<BigNumberish>,
    merkleProof: PromiseOrValue<BytesLike>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  claimMany(
    indices: PromiseOrValue<BigNumberish>[],
    claimTypes: PromiseOrValue<BigNumberish>[],
    claimants: PromiseOrValue<string>[],
    claimableAmounts: PromiseOrValue<BigNumberish>[],
    claimedAmounts: PromiseOrValue<BigNumberish>[],
    merkleProofs: PromiseOrValue<BytesLike>[][],
    sentEth: PromiseOrValue<BigNumberish>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  isClaimed(index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>

  merkleRoot(overrides?: CallOverrides): Promise<string>

  deploymentTimestamp(overrides?: CallOverrides): Promise<BigNumber>

  gnoPrice(overrides?: CallOverrides): Promise<BigNumber>

  usdcPrice(overrides?: CallOverrides): Promise<BigNumber>

  nativeTokenPrice(overrides?: CallOverrides): Promise<BigNumber>

  swappableBalanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>

  balanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>

  swapAll(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>

  callStatic: {
    claim(
      index: PromiseOrValue<BigNumberish>,
      claimType: PromiseOrValue<BigNumberish>,
      claimant: PromiseOrValue<string>,
      claimableAmount: PromiseOrValue<BigNumberish>,
      claimedAmount: PromiseOrValue<BigNumberish>,
      merkleProof: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>

    claimMany(
      indices: PromiseOrValue<BigNumberish>[],
      claimTypes: PromiseOrValue<BigNumberish>[],
      claimants: PromiseOrValue<string>[],
      claimableAmounts: PromiseOrValue<BigNumberish>[],
      claimedAmounts: PromiseOrValue<BigNumberish>[],
      merkleProofs: PromiseOrValue<BytesLike>[][],
      sentEth: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>

    isClaimed(index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>

    merkleRoot(overrides?: CallOverrides): Promise<string>

    deploymentTimestamp(overrides?: CallOverrides): Promise<BigNumber>

    gnoPrice(overrides?: CallOverrides): Promise<BigNumber>

    usdcPrice(overrides?: CallOverrides): Promise<BigNumber>

    nativeTokenPrice(overrides?: CallOverrides): Promise<BigNumber>

    swappableBalanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>

    balanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>

    swapAll(overrides?: CallOverrides): Promise<BigNumber>
  }

  filters: {
    'Claimed(uint256,uint8,address,uint256,uint256)'(
      index?: null,
      claimType?: null,
      claimant?: null,
      claimableAmount?: null,
      claimedAmount?: null
    ): ClaimedEventFilter
    Claimed(
      index?: null,
      claimType?: null,
      claimant?: null,
      claimableAmount?: null,
      claimedAmount?: null
    ): ClaimedEventFilter
  }

  estimateGas: {
    claim(
      index: PromiseOrValue<BigNumberish>,
      claimType: PromiseOrValue<BigNumberish>,
      claimant: PromiseOrValue<string>,
      claimableAmount: PromiseOrValue<BigNumberish>,
      claimedAmount: PromiseOrValue<BigNumberish>,
      merkleProof: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    claimMany(
      indices: PromiseOrValue<BigNumberish>[],
      claimTypes: PromiseOrValue<BigNumberish>[],
      claimants: PromiseOrValue<string>[],
      claimableAmounts: PromiseOrValue<BigNumberish>[],
      claimedAmounts: PromiseOrValue<BigNumberish>[],
      merkleProofs: PromiseOrValue<BytesLike>[][],
      sentEth: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    isClaimed(index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>

    merkleRoot(overrides?: CallOverrides): Promise<BigNumber>

    deploymentTimestamp(overrides?: CallOverrides): Promise<BigNumber>

    gnoPrice(overrides?: CallOverrides): Promise<BigNumber>

    usdcPrice(overrides?: CallOverrides): Promise<BigNumber>

    nativeTokenPrice(overrides?: CallOverrides): Promise<BigNumber>

    swappableBalanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>

    balanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>

    swapAll(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>
  }

  populateTransaction: {
    claim(
      index: PromiseOrValue<BigNumberish>,
      claimType: PromiseOrValue<BigNumberish>,
      claimant: PromiseOrValue<string>,
      claimableAmount: PromiseOrValue<BigNumberish>,
      claimedAmount: PromiseOrValue<BigNumberish>,
      merkleProof: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    claimMany(
      indices: PromiseOrValue<BigNumberish>[],
      claimTypes: PromiseOrValue<BigNumberish>[],
      claimants: PromiseOrValue<string>[],
      claimableAmounts: PromiseOrValue<BigNumberish>[],
      claimedAmounts: PromiseOrValue<BigNumberish>[],
      merkleProofs: PromiseOrValue<BytesLike>[][],
      sentEth: PromiseOrValue<BigNumberish>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    isClaimed(index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>

    merkleRoot(overrides?: CallOverrides): Promise<PopulatedTransaction>

    deploymentTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>

    gnoPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>

    usdcPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>

    nativeTokenPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>

    swappableBalanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>

    balanceOf(user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>

    swapAll(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>
  }
}
