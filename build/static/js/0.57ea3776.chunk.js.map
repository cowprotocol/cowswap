{"version":3,"sources":["../node_modules/@cowprotocol/cow-sdk/node_modules/multiformats/cjs/src/bytes.js","../node_modules/@cowprotocol/cow-sdk/node_modules/multiformats/cjs/src/varint.js","../node_modules/@cowprotocol/cow-sdk/node_modules/multiformats/cjs/src/bases/base.js","../node_modules/@cowprotocol/cow-sdk/node_modules/multiformats/cjs/vendor/varint.js","../node_modules/@cowprotocol/cow-sdk/node_modules/multiformats/cjs/src/hashes/digest.js","../node_modules/@cowprotocol/cow-sdk/node_modules/multiformats/cjs/src/bases/base58.js","../node_modules/@cowprotocol/cow-sdk/node_modules/multiformats/cjs/vendor/base-x.js","../node_modules/@cowprotocol/cow-sdk/node_modules/multiformats/cjs/src/bases/base32.js","../node_modules/@cowprotocol/cow-sdk/node_modules/multiformats/cjs/src/cid.js"],"names":["Object","defineProperty","exports","value","empty","Uint8Array","coerce","o","constructor","name","ArrayBuffer","isView","buffer","byteOffset","byteLength","Error","equals","aa","bb","ii","fromHex","hex","hexes","match","map","b","parseInt","fromString","str","TextEncoder","encode","isBinary","toHex","d","reduce","byte","toString","padStart","TextDecoder","decode","varint$1","require","data","bytes","encodeTo","int","target","offset","encodingLength","baseX$1","Encoder","prefix","baseEncode","this","Decoder","baseDecode","undefined","codePointAt","prefixCodePoint","text","JSON","stringify","slice","length","decoder","or","ComposedDecoder","decoders","input","RangeError","keys","left","right","Codec","encoder","from","baseX","alphabet","rfc4648","bitsPerChar","pad","mask","out","bits","i","string","codes","end","written","SyntaxError","encode_1","num","oldOffset","INT","Math","pow","read","buf","res","shift","counter","l","N1","N2","N3","N4","N5","N6","N7","N8","N9","module","varint","Digest","code","size","digest","create","sizeOffset","digestOffset","set","multihash","bytes$1","subarray","a","base","base58btc","base58flickr","_brrp__multiformats_scope_baseX","ALPHABET","TypeError","BASE_MAP","j","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","log","iFACTOR","decodeUnsafe","source","psz","zeroes","b256","carry","it3","it4","vch","Array","isArray","pbegin","pend","b58","it1","it2","repeat","base32","base32upper","base32pad","base32padupper","base32hex","base32hexupper","base32hexpad","base32hexpadupper","base32z","base58","CID","version","asCID","_baseCache","Map","defineProperties","hidden","readonly","DAG_PB_CODE","SHA_256_CODE","createV0","digest$1","createV1","other","toStringV0","toStringV1","hash","deprecate","IS_CID_DEPRECATION","cidSymbol","encodeCID","decodeFirst","cid","specs","inspectBytes","prefixSize","multihashSize","multihashBytes","digestBytes","digestSize","multihashCode","codec","initialBytes","next","parseCIDtoBytes","Symbol","toStringTag","for","cache","get","codeOffset","hashOffset","writable","configurable","enumerable","range","message","test","console","warn"],"mappings":"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","file":"static/js/0.57ea3776.chunk.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst empty = new Uint8Array(0);\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\nconst fromHex = hex => {\n  const hexes = hex.match(/../g);\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n};\nconst equals = (aa, bb) => {\n  if (aa === bb)\n    return true;\n  if (aa.byteLength !== bb.byteLength) {\n    return false;\n  }\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false;\n    }\n  }\n  return true;\n};\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n    return o;\n  if (o instanceof ArrayBuffer)\n    return new Uint8Array(o);\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n};\nconst isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);\nconst fromString = str => new TextEncoder().encode(str);\nconst toString = b => new TextDecoder().decode(b);\n\nexports.coerce = coerce;\nexports.empty = empty;\nexports.equals = equals;\nexports.fromHex = fromHex;\nexports.fromString = fromString;\nexports.isBinary = isBinary;\nexports.toHex = toHex;\nexports.toString = toString;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar varint$1 = require('../vendor/varint.js');\n\nconst decode = data => {\n  const code = varint$1.decode(data);\n  return [\n    code,\n    varint$1.decode.bytes\n  ];\n};\nconst encodeTo = (int, target, offset = 0) => {\n  varint$1.encode(int, target, offset);\n  return target;\n};\nconst encodingLength = int => {\n  return varint$1.encodingLength(int);\n};\n\nexports.decode = decode;\nexports.encodeTo = encodeTo;\nexports.encodingLength = encodingLength;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar baseX$1 = require('../../vendor/base-x.js');\nvar bytes = require('../bytes.js');\n\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${ this.prefix }${ this.baseEncode(bytes) }`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);\n    }\n  }\n}\nconst or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nclass Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nconst from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);\nconst baseX = ({prefix, name, alphabet}) => {\n  const {encode, decode} = baseX$1(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => bytes.coerce(decode(text))\n  });\n};\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${ name } character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\nconst rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n  });\n};\n\nexports.Codec = Codec;\nexports.baseX = baseX;\nexports.from = from;\nexports.or = or;\nexports.rfc4648 = rfc4648;\n","'use strict';\n\nvar encode_1 = encode;\nvar MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n  while (num >= INT) {\n    out[offset++] = num & 255 | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    out[offset++] = num & 255 | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  encode.bytes = offset - oldOffset + 1;\n  return out;\n}\nvar decode = read;\nvar MSB$1 = 128, REST$1 = 127;\nfunction read(buf, offset) {\n  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint');\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1);\n  read.bytes = counter - offset;\n  return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (value) {\n  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n};\nvar varint = {\n  encode: encode_1,\n  decode: decode,\n  encodingLength: length\n};\nvar _brrp_varint = varint;\nvar varint$1 = _brrp_varint;\n\nmodule.exports = varint$1;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar bytes = require('../bytes.js');\nvar varint = require('../varint.js');\n\nconst create = (code, digest) => {\n  const size = digest.byteLength;\n  const sizeOffset = varint.encodingLength(code);\n  const digestOffset = sizeOffset + varint.encodingLength(size);\n  const bytes = new Uint8Array(digestOffset + size);\n  varint.encodeTo(code, bytes, 0);\n  varint.encodeTo(size, bytes, sizeOffset);\n  bytes.set(digest, digestOffset);\n  return new Digest(code, size, digest, bytes);\n};\nconst decode = multihash => {\n  const bytes$1 = bytes.coerce(multihash);\n  const [code, sizeOffset] = varint.decode(bytes$1);\n  const [size, digestOffset] = varint.decode(bytes$1.subarray(sizeOffset));\n  const digest = bytes$1.subarray(sizeOffset + digestOffset);\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length');\n  }\n  return new Digest(code, size, digest, bytes$1);\n};\nconst equals = (a, b) => {\n  if (a === b) {\n    return true;\n  } else {\n    return a.code === b.code && a.size === b.size && bytes.equals(a.bytes, b.bytes);\n  }\n};\nclass Digest {\n  constructor(code, size, digest, bytes) {\n    this.code = code;\n    this.size = size;\n    this.digest = digest;\n    this.bytes = bytes;\n  }\n}\n\nexports.Digest = Digest;\nexports.create = create;\nexports.decode = decode;\nexports.equals = equals;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar base = require('./base.js');\n\nconst base58btc = base.baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nconst base58flickr = base.baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});\n\nexports.base58btc = base58btc;\nexports.base58flickr = base58flickr;\n","'use strict';\n\nfunction base(ALPHABET, name) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError('Alphabet too long');\n  }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + ' is ambiguous');\n    }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256);\n  var iFACTOR = Math.log(256) / Math.log(BASE);\n  function encode(source) {\n    if (source instanceof Uint8Array);\n    else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) {\n      throw new TypeError('Expected Uint8Array');\n    }\n    if (source.length === 0) {\n      return '';\n    }\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size);\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      pbegin++;\n    }\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n    return str;\n  }\n  function decodeUnsafe(source) {\n    if (typeof source !== 'string') {\n      throw new TypeError('Expected String');\n    }\n    if (source.length === 0) {\n      return new Uint8Array();\n    }\n    var psz = 0;\n    if (source[psz] === ' ') {\n      return;\n    }\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n    var size = (source.length - psz) * FACTOR + 1 >>> 0;\n    var b256 = new Uint8Array(size);\n    while (source[psz]) {\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n      if (carry === 255) {\n        return;\n      }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      psz++;\n    }\n    if (source[psz] === ' ') {\n      return;\n    }\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch;\n  }\n  function decode(string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) {\n      return buffer;\n    }\n    throw new Error(`Non-${ name } character`);\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\n\nmodule.exports = _brrp__multiformats_scope_baseX;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar base = require('./base.js');\n\nconst base32 = base.rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n});\nconst base32upper = base.rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n});\nconst base32pad = base.rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n});\nconst base32padupper = base.rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n});\nconst base32hex = base.rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n});\nconst base32hexupper = base.rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n});\nconst base32hexpad = base.rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n});\nconst base32hexpadupper = base.rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n});\nconst base32z = base.rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n});\n\nexports.base32 = base32;\nexports.base32hex = base32hex;\nexports.base32hexpad = base32hexpad;\nexports.base32hexpadupper = base32hexpadupper;\nexports.base32hexupper = base32hexupper;\nexports.base32pad = base32pad;\nexports.base32padupper = base32padupper;\nexports.base32upper = base32upper;\nexports.base32z = base32z;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar varint = require('./varint.js');\nvar digest = require('./hashes/digest.js');\nvar base58 = require('./bases/base58.js');\nvar base32 = require('./bases/base32.js');\nvar bytes = require('./bytes.js');\n\nclass CID {\n  constructor(version, code, multihash, bytes) {\n    this.code = code;\n    this.version = version;\n    this.multihash = multihash;\n    this.bytes = bytes;\n    this.byteOffset = bytes.byteOffset;\n    this.byteLength = bytes.byteLength;\n    this.asCID = this;\n    this._baseCache = new Map();\n    Object.defineProperties(this, {\n      byteOffset: hidden,\n      byteLength: hidden,\n      code: readonly,\n      version: readonly,\n      multihash: readonly,\n      bytes: readonly,\n      _baseCache: hidden,\n      asCID: hidden\n    });\n  }\n  toV0() {\n    switch (this.version) {\n    case 0: {\n        return this;\n      }\n    default: {\n        const {code, multihash} = this;\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n        }\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n        }\n        return CID.createV0(multihash);\n      }\n    }\n  }\n  toV1() {\n    switch (this.version) {\n    case 0: {\n        const {code, digest: digest$1} = this.multihash;\n        const multihash = digest.create(code, digest$1);\n        return CID.createV1(this.code, multihash);\n      }\n    case 1: {\n        return this;\n      }\n    default: {\n        throw Error(`Can not convert CID version ${ this.version } to version 0. This is a bug please report`);\n      }\n    }\n  }\n  equals(other) {\n    return other && this.code === other.code && this.version === other.version && digest.equals(this.multihash, other.multihash);\n  }\n  toString(base) {\n    const {bytes, version, _baseCache} = this;\n    switch (version) {\n    case 0:\n      return toStringV0(bytes, _baseCache, base || base58.base58btc.encoder);\n    default:\n      return toStringV1(bytes, _baseCache, base || base32.base32.encoder);\n    }\n  }\n  toJSON() {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return 'CID';\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return 'CID(' + this.toString() + ')';\n  }\n  static isCID(value) {\n    deprecate(/^0\\.0/, IS_CID_DEPRECATION);\n    return !!(value && (value[cidSymbol] || value.asCID === value));\n  }\n  get toBaseEncodedString() {\n    throw new Error('Deprecated, use .toString()');\n  }\n  get codec() {\n    throw new Error('\"codec\" property is deprecated, use integer \"code\" property instead');\n  }\n  get buffer() {\n    throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');\n  }\n  get multibaseName() {\n    throw new Error('\"multibaseName\" property is deprecated');\n  }\n  get prefix() {\n    throw new Error('\"prefix\" property is deprecated');\n  }\n  static asCID(value) {\n    if (value instanceof CID) {\n      return value;\n    } else if (value != null && value.asCID === value) {\n      const {version, code, multihash, bytes} = value;\n      return new CID(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));\n    } else if (value != null && value[cidSymbol] === true) {\n      const {version, multihash, code} = value;\n      const digest$1 = digest.decode(multihash);\n      return CID.create(version, code, digest$1);\n    } else {\n      return null;\n    }\n  }\n  static create(version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported');\n    }\n    switch (version) {\n    case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(`Version 0 CID must use dag-pb (code: ${ DAG_PB_CODE }) block encoding`);\n        } else {\n          return new CID(version, code, digest, digest.bytes);\n        }\n      }\n    case 1: {\n        const bytes = encodeCID(version, code, digest.bytes);\n        return new CID(version, code, digest, bytes);\n      }\n    default: {\n        throw new Error('Invalid version');\n      }\n    }\n  }\n  static createV0(digest) {\n    return CID.create(0, DAG_PB_CODE, digest);\n  }\n  static createV1(code, digest) {\n    return CID.create(1, code, digest);\n  }\n  static decode(bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes);\n    if (remainder.length) {\n      throw new Error('Incorrect length');\n    }\n    return cid;\n  }\n  static decodeFirst(bytes$1) {\n    const specs = CID.inspectBytes(bytes$1);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = bytes.coerce(bytes$1.subarray(prefixSize, prefixSize + specs.multihashSize));\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length');\n    }\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest$1 = new digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid = specs.version === 0 ? CID.createV0(digest$1) : CID.createV1(specs.codec, digest$1);\n    return [\n      cid,\n      bytes$1.subarray(specs.size)\n    ];\n  }\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset));\n      offset += length;\n      return i;\n    };\n    let version = next();\n    let codec = DAG_PB_CODE;\n    if (version === 18) {\n      version = 0;\n      offset = 0;\n    } else if (version === 1) {\n      codec = next();\n    }\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${ version }`);\n    }\n    const prefixSize = offset;\n    const multihashCode = next();\n    const digestSize = next();\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n  static parse(source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base);\n    const cid = CID.decode(bytes);\n    cid._baseCache.set(prefix, source);\n    return cid;\n  }\n}\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n  case 'Q': {\n      const decoder = base || base58.base58btc;\n      return [\n        base58.base58btc.prefix,\n        decoder.decode(`${ base58.base58btc.prefix }${ source }`)\n      ];\n    }\n  case base58.base58btc.prefix: {\n      const decoder = base || base58.base58btc;\n      return [\n        base58.base58btc.prefix,\n        decoder.decode(source)\n      ];\n    }\n  case base32.base32.prefix: {\n      const decoder = base || base32.base32;\n      return [\n        base32.base32.prefix,\n        decoder.decode(source)\n      ];\n    }\n  default: {\n      if (base == null) {\n        throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n      }\n      return [\n        source[0],\n        base.decode(source)\n      ];\n    }\n  }\n};\nconst toStringV0 = (bytes, cache, base) => {\n  const {prefix} = base;\n  if (prefix !== base58.base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${ base.name } encoding`);\n  }\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst toStringV1 = (bytes, cache, base) => {\n  const {prefix} = base;\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst DAG_PB_CODE = 112;\nconst SHA_256_CODE = 18;\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version);\n  const hashOffset = codeOffset + varint.encodingLength(code);\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint.encodeTo(version, bytes, 0);\n  varint.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\nconst readonly = {\n  writable: false,\n  configurable: false,\n  enumerable: true\n};\nconst hidden = {\n  writable: false,\n  enumerable: false,\n  configurable: false\n};\nconst version = '0.0.0-dev';\nconst deprecate = (range, message) => {\n  if (range.test(version)) {\n    console.warn(message);\n  } else {\n    throw new Error(message);\n  }\n};\nconst IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n`;\n\nexports.CID = CID;\n"],"sourceRoot":""}