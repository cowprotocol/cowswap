


import{g as P,d3 as h,aZ as v,y as L,B as b}from"./vendor-35db3a09.js";import{eT as y,eU as w,eV as x,eW as I,eX as R,eY as B,eZ as F,e_ as S,e$ as k,f0 as $}from"./index-a8951d67.js";const f="1inch",O=[P.SupportedChainId.MAINNET,P.SupportedChainId.GNOSIS_CHAIN],M=new Map(O.map(e=>[e,`https://api.1inch.io/v5.0/${e}`])),Q={"Content-Type":"application/json"},G=y({rateLimit:{tokensPerInterval:5,interval:"second"}});function j(e){return M.get(e)||null}function q(e){if(!e)return null;const{toToken:t,toTokenAmount:n}=e;return{amount:n,token:t.address}}function H(e,t,n,o){const r=j(e);return r?G(r+t,{headers:Q,method:n,body:o!==void 0?JSON.stringify(o):o}):null}function W(e,t){return H(e,t,"GET")}async function Y(e){const{baseToken:t,quoteToken:n,amount:o,kind:r,chainId:i}=w(e);console.log(`[pricesApi:${f}] Get price from ${f}`,e);const{sellToken:c,buyToken:s}=x({baseToken:t,quoteToken:n,kind:r});if(e.kind===h.BUY)return console.debug(`[pricesApi:${f}] ${f} API don't support BUY Orders`,e),null;const u=W(i,`/quote?fromTokenAddress=${c}&toTokenAddress=${s}&amount=${o}`);return u?(await u.catch(l=>{throw console.error(`Error getting ${f} price quote:`,l),new Error(l)})).json():null}class V extends Error{constructor(t,n,o){super(t),this.params=n,this.results=o}}function X(e){switch(e){case P.SupportedChainId.MAINNET:return e;default:return null}}function J(){return{[P.SupportedChainId.MAINNET]:"https://api.0x.org/swap"}}const A="Matcha(0x)",Z=J(),K="v1",z={"Content-Type":"application/json"},ee="0x9008D19f58AAbD9eD0D60971565AA8510560ab41",te="",oe=`affiliateAddress=${ee}&excludedSources=${te}`,ne=y({rateLimit:{tokensPerInterval:3,interval:"second"}});function re(e){const t=Z[e];if(t)return t+"/"+K;throw new Error(`Unsupported Network. The ${A} API is not deployed in the Network ${e}`)}function se(e,t,n,o){const r=re(e);return ne(r+t,{headers:z,method:n,body:o!==void 0?JSON.stringify(o):o})}function ie(e,t){return se(e,t,"GET")}async function ce(e){const{baseToken:t,quoteToken:n,amount:o,kind:r,chainId:i}=w(e);if(X(i)==null)return null;console.log(`[pricesApi:${A}] Get price from ${A}`,e);const{sellToken:s,buyToken:u}=x({baseToken:t,quoteToken:n,kind:r}),a=r===h.BUY?"buyAmount":"sellAmount";return(await ie(i,`/price?sellToken=${s}&buyToken=${u}&${a}=${o}&${oe}`).catch(d=>{throw console.error(`Error getting ${A} price quote:`,d),new Error(d)})).json()}function ue(e,t){if(!e||!e.price)return null;const{sellAmount:n,buyAmount:o,sellTokenAddress:r,buyTokenAddress:i}=e;return t===h.BUY?{amount:n,token:r}:{amount:o,token:i}}const ae=new I({errorType:R.FeeExceedsFrom,description:I.quoteErrorDetails.FeeExceedsFrom});function le(e){const t=e.aggrOverride||e.kind===h.SELL?"max":"min",n=b[t](...e.amounts).toString(10),o=e.priceQuotes[0].token,r=e.priceQuotes.filter(i=>i.amount===n).map(i=>i.source).join(", ");return console.debug("[util::filterWinningPrice] Winning price: "+r+" for token "+o+" @",n),{token:o,amount:n}}async function fe(e){const t=S(ce(e),$,"Matcha(0x): Get Price API"),n=S(Y(e),$,"1inch: Get Price API"),[o,r]=await Promise.allSettled([t,n]);return{gpPriceResult:{status:"fulfilled",value:null},paraSwapPriceResult:{status:"fulfilled",value:null},matcha0xPriceResult:o,oneInchPriceResult:r}}function de(e,t,n,o,r){const i=[],c=[];if(k(t)){const s=t.value;s&&i.push({...s,source:"gnosis-protocol"})}else c.push({...t,source:"gnosis-protocol"});if(k(o)){const s=ue(o.value,e);s&&i.push({...s,source:"matcha-0x",data:o.value})}else c.push({...o,source:"matcha-0x"});if(k(r)){const s=q(r.value);s&&i.push({...s,source:"1inch",data:s.amount})}else c.push({...r,source:"1inch"});return[i,c]}function pe(e){console.warn("[getBestQuote:Legacy]::Fee error",e);const t=e?.data?.fee_amount||e?.data?.feeAmount,n=e?.data?.expiration;if(t)return{amount:t,expirationDate:n};throw e}function _(e,t){return typeof t!="number"?e:b(e).div(10**t).toString()}async function me(e,t){const{gpPriceResult:n,paraSwapPriceResult:o,matcha0xPriceResult:r,oneInchPriceResult:i}=await fe(e),[c,s]=de(e.kind,n,o,r,i);if(s.length>0){const u=s.map(a=>a.source).join(", ");console.error("[utils::useRefetchPriceCallback] Some API failed or timed out: "+u,s)}if(c.length>0){const u=c.map(l=>l.source).join(", ");console.log("[utils::useRefetchPriceCallback] Get best price succeeded for "+u,c);const a=c.map(l=>l.amount).filter(Boolean);return le({...t,kind:e.kind,amounts:a,priceQuotes:c})}else{const u=new V("Error querying price from APIs",e,[n,o,r]),a=new Error;throw Object.assign(a,u,{message:"Error querying best price from APIs",name:"PriceErrorObject"}),v(a,{tags:{errorType:"getBestPrice"},contexts:{params:e}}),u}}async function Pe({quoteParams:e,fetchFee:t,previousFee:n}){const{sellToken:o,buyToken:r,fromDecimals:i,toDecimals:c,amount:s,kind:u,chainId:a,userAddress:l,validTo:d,priceQuality:D}=e,{baseToken:N,quoteToken:U}=B({sellToken:o,buyToken:r,kind:u}),T=t||!n?F(e).then(m=>({amount:m.quote.feeAmount,expirationDate:m.expiration})).catch(pe):Promise.resolve(n);let p,E=!1;if(u==="sell"){const{amount:m}=await T,g=L.from(s).sub(m);console.log(`Sell amount before fee: ${_(s,i)}  (in atoms ${s})`),console.log(`Sell amount after fee: ${_(g.toString(),i)}  (in atoms ${g})`),E=g.lte("0"),p=E?null:g.toString()}else p=s;const C=!E&&p?me({chainId:a,baseToken:N,quoteToken:U,fromDecimals:i,toDecimals:c,amount:p,kind:u,userAddress:l,validTo:d,priceQuality:D}):Promise.reject(ae);return Promise.allSettled([C,T])}export{me as getBestPrice,Pe as getBestQuoteLegacy};
